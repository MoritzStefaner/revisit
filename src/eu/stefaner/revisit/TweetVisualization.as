/*     Copyright 2010, Moritz Stefaner   Licensed under the Apache License, Version 2.0 (the "License");   you may not use this file except in compliance with the License.   You may obtain a copy of the License at       http://www.apache.org/licenses/LICENSE-2.0   Unless required by applicable law or agreed to in writing, software   distributed under the License is distributed on an "AS IS" BASIS,   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   See the License for the specific language governing permissions and   limitations under the License.    */package eu.stefaner.revisit {	import flare.animate.TransitionEvent;	import flare.animate.Transitioner;	import flare.display.TextSprite;	import flare.scale.ScaleType;	import flare.scale.TimeScale;	import flare.util.Arrays;	import flare.util.Maths;	import flare.vis.Visualization;	import flare.vis.axis.Axis;	import flare.vis.axis.AxisGridLine;	import flare.vis.data.Data;	import flare.vis.data.DataList;	import flare.vis.data.NodeSprite;	import flare.vis.data.ScaleBinding;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.geom.Rectangle;	import flash.text.TextFormat;	import flash.utils.Dictionary;	/**	 * @author mo	 */	public class TweetVisualization extends Visualization {		private var app : App;		private static const LEFT : String = "LEFT";		private static const MIDDLE : String = "MIDDLE";		private static const RIGHT : String = "RIGHT";		private var leftAxis : Axis;		private var middleAxis : Axis;		private var rightAxis : Axis;		private var mainAxis : Axis;		// left end of focus time axis (date.time)		private var leftBorder : Number = -1;		// left end of focus time axis (date.time)		private var rightBorder : Number = -1;		// index of leftmost focussed item		private var leftIndex : int = -1;		// index of rightmost focussed item		private var rightIndex : int = -1;		// index of currently selected item		public var currentIndex : int = -1;		public var highlightedTweet : TweetSprite;		public var tweetByID : Dictionary = new Dictionary();		private var tweetsByUser : Dictionary = new Dictionary();		public var tweetsByImportance : DataList = new DataList("tweetsByImportance");		private var transitioner : Transitioner;		private var oldGridlinePositions : Dictionary = new Dictionary();		public var transitionProgress : Number = 0;		private var minDate : Date;		public var maxDate : Date;		private var leftNodes : DataList;		private var middleNodes : DataList;		private var rightNodes : DataList;		public function TweetVisualization(app : App, b : Rectangle) {			super();			bounds = b;			this.app = app;			data = new Data();			leftNodes = data.addGroup(LEFT);			middleNodes = data.addGroup(MIDDLE);			rightNodes = data.addGroup(RIGHT);			addEventListener(MouseEvent.CLICK, onClick);		}		protected function initAxes() : void {			leftAxis = getAxis(getScaleBinding(LEFT));			middleAxis = getAxis(getScaleBinding(MIDDLE, true));			rightAxis = getAxis(getScaleBinding(RIGHT));			mainAxis = createMainAxis();			leftAxis.y1 = 0;			leftAxis.y2 = 0;			middleAxis.y1 = 20;			middleAxis.y2 = 20;			rightAxis.y1 = 0;			rightAxis.y2 = 0;			middleAxis.labelTextFormat = new TextFormat("FlamaMedium", 14, 0xAAAAAA, true);			middleAxis.labelTextMode = TextSprite.EMBED;		}		private function createMainAxis() : Axis {			var a : Axis = new Axis();			a.axisScale = new TimeScale();			a.axisScale.flush = false;			a.showLabels = true;			if (Settings.showOnlyToday) a.labelFormat = "HH:mm";			a.showLines = true;			a.lineLengthY = -10;			a.labelOffsetY = 0;			a.lineColor = 0x999999;			a.lineWidth = 1;			a.x1 = 0;			a.x2 = bounds.width;			a.y1 = bounds.height;			a.y2 = bounds.height;			a.fixLabelOverlap = true;			a.labelTextFormat = new TextFormat("FlamaMedium", 12, 0xCCCCCC, true);			a.labelTextMode = TextSprite.EMBED;			a.labelOffsetX = -3;			a.lineColor = 0x333333;			addChild(a);			return a;		}		private function getScaleBinding(group : String, inCenter : Boolean = false) : ScaleBinding {			var s : ScaleBinding = new ScaleBinding();			s.scaleType = ScaleType.TIME;			s.group = group;			s.property = "data.date";			s.data = data;			s.flush = true;			return s;		}		private function getAxis(timeScaleBinding : ScaleBinding, showLabels : Boolean = false) : Axis {			var a : Axis;			a = new Axis(timeScaleBinding);			a.showLabels = showLabels;			a.showLines = showLabels;			a.lineLengthY = 10;			a.labelOffsetY = 15;			a.lineColor = 0x999999;			a.lineWidth = 1;			a.y1 = bounds.height;			a.y2 = bounds.height;			a.fixLabelOverlap = true;			a.labelTextFormat = new TextFormat("FlamaMedium", 10, 0x777777, true);			a.labelOffsetX = -3;			a.lineColor = 0x333333;			addChild(a);			return a;		}		// EVENT HANDLERS		private function onClick(e : MouseEvent) : void {			if (e.target is TweetSprite) app.onNodeClick(TweetSprite(e.target));		}		protected function onTransitionStep(event : Event) : void {			drawConnectionsToTimeLine();		}		// CONTROLS		public function displayTweet(ts : TweetSprite = null) : void {			for (var i : int = 0;i < data.nodes.length;i++) {				if (data.nodes[i] == ts) {					currentIndex = i;					ts.isNew = false;					doUpdate();					return;				}			}			currentIndex = -1;			doUpdate();		}		public function displayNext() : void {			advance(1);		}		public function displayPrevious() : void {			advance(-1);		}		public function advance(advanceSteps : Number = 1) : void {			currentIndex += advanceSteps;			doUpdate();		}		public function displayRandom() : void {			if (!data.nodes.length) return;			var ts : TweetSprite ;			if (Math.random() > .75 && highlightedTweet) {				// display nothing				ts = null;			} else if (Math.random() > .5) {				// pick important				ts = tweetsByImportance[Math.floor(tweetsByImportance.length * (1 - Math.pow(Math.random(), .66)))];			} else {				// pick new				ts = data.nodes[Math.floor(data.nodes.length * (Math.pow(Math.random(), .66)))];			}			displayTweet(ts);		}		override public function update(t : * = null, ...operators) : Transitioner {			// t = super.update(t);			t = Transitioner.instance(t);			if (!data.nodes.length) {				return t;			}			data.nodes.sortBy("data.dateTime");			minDate = data.nodes[0].data.date;			maxDate = data.nodes[data.nodes.length - 1].data.date;			updateWindow();			updateGroups();			updateAxisPositions(t);			updateTweetSprites(t);			fixOverlaps(t);			updateEdges(t);			if (highlightedTweet) addChild(highlightedTweet);			return t;		}		private function updateEdges(t : Transitioner) : void {			var n : TweetSprite;			for each (n in data.nodes) {				n.updateEdges(t);			}			/*			for each (var e:TweetConnection in data.edges) {			e.update(t);			}			 */		}		private function updateGroups() : void {			leftNodes.clear();			middleNodes.clear();			rightNodes.clear();			for (var i : int = 0;i <= leftIndex;i++) {				leftNodes.add(data.nodes[i]);				data.nodes[i].axis = leftAxis;			}			for (;i < rightIndex;i++) {				middleNodes.add(data.nodes[i]);				data.nodes[i].axis = middleAxis;			}			for (;i < data.nodes.length;i++) {				rightNodes.add(data.nodes[i]);				data.nodes[i].axis = rightAxis;			}		}		private function updateAxisPositions(t : Transitioner) : void {			var pastSpan : Number = leftBorder - minDate.time;			var futureSpan : Number = maxDate.time - rightBorder;			var totalSpan : Number = maxDate.time - minDate.time;			var focusWindowWidth : Number = middleNodes.length ? Settings.focusWindowWidth : 0;			var minSize : Number = Settings.minAxisWidth;			var w1 : Number = (bounds.width - focusWindowWidth) * (pastSpan / totalSpan);			var w2 : Number = focusWindowWidth;			var w3 : Number = (bounds.width - focusWindowWidth) * (futureSpan / totalSpan);			if (leftNodes.length && (w1 < minSize)) {				w3 -= minSize - w1;				w1 = minSize;			}			if (rightNodes.length && (w3 < minSize)) {				w1 -= minSize - w3;				w3 = minSize;			}			leftAxis.x1 = 0;			leftAxis.x2 = w1;			middleAxis.x1 = leftAxis.x2;			middleAxis.x2 = leftAxis.x2 + w2;			rightAxis.x1 = middleAxis.x2;			rightAxis.x2 = middleAxis.x2 + w3;			(leftAxis.axisScale as ScaleBinding).updateBinding();			(middleAxis.axisScale as ScaleBinding).updateBinding();			(rightAxis.axisScale as ScaleBinding).updateBinding();			(mainAxis.axisScale as TimeScale).min = minDate;			(mainAxis.axisScale as TimeScale).max = maxDate;			leftAxis.update(t);			middleAxis.update(t);			rightAxis.update(t);			mainAxis.update(t);		}		private function updateTweetSprites(t : Transitioner) : void {			var n : TweetSprite;			data.edges.setProperties({"expanded":false});			data.nodes.setProperties({"highlighted":false, "retweetSourceHighlighted":false, "retweetTargetHighlighted":false, "referenceSourceHighlighted":false, "referenceTargetHighlighted":false});			if (!highlightedTweet) {				for each (n in data.nodes) {					n.updateAppearance(t, n.axis == middleAxis, bounds.height * .5);				}				return;			}			// highlight focused tweet			highlightedTweet.highlighted = true;			// highlight connected tweets			highlightedTweet.visitEdges(function(e : TweetConnection) {				e.expanded = true;				var target : TweetSprite = TweetSprite(e.other(highlightedTweet));				if (e.type == "retweet") {					if (target == e.target) {						// target is retweet of highlighted						target.retweetTargetHighlighted = true;						// show the other retweets, too						target.visitEdges(function(e2 : TweetConnection) {							e2.expanded = true;						});					} else {						// highlighted is retweet of target						target.retweetSourceHighlighted = true;					}				}				if (e.type == "reference") {					if (target == e.source) {						target.referenceSourceHighlighted = true;					} else {						target.referenceTargetHighlighted = true;					}				}			}, NodeSprite.ALL_LINKS);			for each (n in data.nodes) {				n.updateAppearance(t, n.axis == middleAxis, bounds.height * .5);				if (n.appearance == TweetSprite.EXPANDED) {					addChild(n);				} else {					addChildAt(n, 0);				}			}			addChild(highlightedTweet);		}		private function fixOverlaps(t : Transitioner) : void {			updateTweetsByImportanceSorting();			var minY : Number = 100000;			var maxY : Number = -100000;			var margin : Number;			for each (var n:TweetSprite in tweetsByImportance) {				var yy : Number = t.$(n).y;				if (n.appearance == TweetSprite.EXPANDED) {					margin = 4 * Settings.minSpacing;				} else {					margin = TweetSprite.baseScale * Settings.minSpacing;				}				var intersects : Boolean = true;				while (intersects) {					yy += n.props.moveDirection;					t.$(n).y = yy;					n.invalidateEndBounds();					intersects = false;					var b1 : Rectangle = n.getEndBounds(t).clone();					b1.width += margin;					for each (var n2:TweetSprite in tweetsByImportance) {						if (n == n2) {							break;						}						var b2 : Rectangle = n2.getEndBounds(t).clone();						b2.width += margin;						/*						var b1 : Rectangle = n.getEndBounds(t);						var b2 : Rectangle = n2.getEndBounds(t);						 */						if (b1.intersects(b2)) {							intersects = true;							break;						}					}				}				yy += n.props.moveDirection * margin;				minY = Math.min(yy, minY);				maxY = Math.max(yy + n.getEndBounds(t).height, maxY);				t.$(n).y = Math.floor(yy);				n.invalidateEndBounds();			}			// adjust basescale			if (highlightedTweet) {				var heightDiff : Number = (maxY - minY) - bounds.height;				if (heightDiff > 0) {					TweetSprite.baseScale -= .1;				} else if (heightDiff < -200) {					TweetSprite.baseScale += .05;				}				TweetSprite.baseScale = Math.min(Math.max(TweetSprite.baseScale, .5), 2);			}			// Logger.info("new baseScale", TweetSprite.baseScale);		}		private function updateTweetsByImportanceSorting() : void {			tweetsByImportance.sortBy(["-activationLevel", "data.random"]);		}		public function doUpdate() : void {			if (!leftAxis) {				initAxes();			}			storeOldGridlinePositions();			if (transitioner) {				if (transitioner.running) {					transitioner.stop();				}			}			transitioner = new Transitioner(Settings.transitionLength, null, true);			transitioner.addEventListener(TransitionEvent.STEP, onTransitionStep, false, 0, true);			transitionProgress = 0;			transitioner.$(this).transitionProgress = 1;			update(transitioner);			transitioner.play();		}		private var moveDirection : Number = -1;		public function addTweetSprite(tweet : TweetData) : TweetSprite {			var ts : TweetSprite = new TweetSprite(tweet);			ts.x = bounds.width;			ts.y = bounds.height * .5;			ts.scaleX = 0;			ts.scaleY = 0;			ts.props.moveDirection = moveDirection;			moveDirection *= -1;			tweetByID[tweet.id] = ts;			data.nodes.add(ts);			tweetsByImportance.add(ts);			if (!tweetsByUser[tweet.userName]) {				tweetsByUser[tweet.userName] = [];			}			tweetsByUser[tweet.userName].push(ts);			var userName : String;			for each (var retweet:String in tweet.retweets) {				userName = retweet.split("@")[1].toLowerCase();				// App.log(this, "retweet " + retweet + ":" + userName);				for each (var ts3:TweetSprite in tweetsByUser[userName]) {					if (tweet.isRetweetOf(TweetData(ts3.data))) {						createEdge(ts, ts3, "retweet");					}				}			}			for each (var reference:String in tweet.references) {				userName = reference.split("@")[1].toLowerCase();				var previous : TweetSprite = null;				for each (var ts3:TweetSprite in tweetsByUser[userName]) {					if (ts3.data.dateTime >= ts.data.dateTime) {						break;					}					previous = ts3;				}				if (previous) {					createEdge(ts, previous, "reference");				}			}			if (data.nodes.length > Settings.maxItems) {				updateTweetsByImportanceSorting();				while (data.nodes.length > Settings.maxItems) {					if (tweetsByImportance[tweetsByImportance.length - 1] != ts) {						removeTweetSprite(tweetsByImportance[tweetsByImportance.length - 1]);					} else {						removeTweetSprite(tweetsByImportance[tweetsByImportance.length - 2]);					}				}			}			return ts;		}		private function removeTweetSprite(ts : TweetSprite) : void {			Arrays.remove(tweetsByUser[ts.data.userName], ts);			tweetsByImportance.remove(ts);			tweetByID[ts.data.id] = null;			data.removeNode(ts);			Arrays.remove(app.newTweets, ts);		}		private function createEdge(ts : NodeSprite, ts2 : NodeSprite, type : String = "") : void {			var e : TweetConnection = new TweetConnection(ts, ts2, type);			ts.addOutEdge(e);			ts2.addInEdge(e);			data.addEdge(e);		}		private function updateWindow() : void {			// currentIndex = Math.max(0, Math.min(data.nodes.length - 1, currentIndex));			if (currentIndex > data.nodes.length - 1 || currentIndex < 0) {				currentIndex = -1;				highlightedTweet = null;				leftIndex = data.nodes.length - 1;				rightIndex = data.nodes.length - 1;			} else {				highlightedTweet = data.nodes[currentIndex];				leftIndex = Math.max(0, currentIndex - Math.max(0, (Settings.windowSize - 1) / 2)) - 1;				rightIndex = Math.min(data.nodes.length - 1, currentIndex + Math.max(0, (Settings.windowSize - 1) / 2)) + 1;			}			leftBorder = leftIndex > 0 ? data.nodes[leftIndex].data.date.time : data.nodes[leftIndex + 1].data.date.time - 1;			rightBorder = rightIndex < data.nodes.length ? data.nodes[rightIndex].data.date.time : data.nodes[rightIndex - 1].data.date.time + 1;		}		private function storeOldGridlinePositions() : void {			var _glines : Sprite = mainAxis.gridLines;			for (var i : uint = 0;i < _glines.numChildren;++i) {				try {					var agl : AxisGridLine = _glines.getChildAt(i) as AxisGridLine;					var ts : Axis = (agl.value.time <= leftBorder) ? leftAxis : rightAxis;					oldGridlinePositions[agl] = ts.X(agl.value);				} catch(error : Error) {				}			}		}		protected function drawConnectionsToTimeLine() : void {			graphics.clear();			var _glines : Sprite = mainAxis.gridLines;			for (var i : uint = 0;i < _glines.numChildren;++i) {				var agl : AxisGridLine = _glines.getChildAt(i) as AxisGridLine;				if (agl.visible && agl.alpha > 0) drawConnectionToGridLine(agl);			}		}		private function drawConnectionToGridLine(agl : AxisGridLine) : void {			var ts : Axis = (agl.value.time <= leftBorder) ? leftAxis : rightAxis;			graphics.lineStyle(1, 0x43494F, .8 * agl.alpha);			var x1 : Number = agl.x1;			var y1 : Number = agl.y1;			var x2 : Number = Maths.linearInterp(transitionProgress, oldGridlinePositions[agl] || 0, ts.X(agl.value));			var y2 : Number = bounds.height * .61;			if (x2 < bounds.width && x2 > 0) {				drawCurve(x1, y1, x2, y2);				graphics.lineTo(x2, 0);			}		}		private function drawCurve(x1 : Number, y1 : Number, x2 : Number, y2 : Number) : void {			graphics.moveTo(x1, y1);			graphics.curveTo(x1, y1 + (y2 - y1) * .33, x1 + (x2 - x1) * .5, y1 + (y2 - y1) * .5);			graphics.curveTo(x2, y2 - (y2 - y1) * .33, x2, y2);		}	}}